### Conceptual Exercise

Answer the following questions below:

- What is a JWT?

> A *JWT* (Jason Web Token) enables a client to store session-type
> information in order to preserve the state of that user being
> logged-in and/or authorized to access some privileged resource.
> This is beneficial since normally client/server web access works through a 
> *stateless* mechanism.
> By using such tokens, a user can enter authentication information just once
> Then, client software can use that token to prove authorization if
> required. The JWT consists of a *payload*, i.e. salient data (e.g. username, 
> isAdmin, etc.) for the token and a *signature* which guarantees that the token
> is authentic (i.e. generated by the server when given some privileged information, 
> such as a password.


- What is the signature portion of the JWT?  What does it do?

> See above.

- If a JWT is intercepted, can the attacker see what's inside the payload?

> Yes. In fact the `decode` function allows one to decode the contents of the
> payload. However, for the token to be used to access some resource on the server,
> the entire token, including the signature, must be sent. 
> The signature much *match* the payload for the token to be trusted.

- How can you implement authentication with a JWT?  Describe how it works at a high level.

> A user could login with a username and their correct password. The server
> would check the password and generate a JWT to represent the fact that
> the user is now logged in.  The username could be part of the payload.
> If that user needed to access a resource, they could
> supply the JWT to demonstrate that they're logged in. A bad actor could not
> simply substitute their own username into the payload of such a token because the 
> signature wouldn't match.

- Compare and contrast unit, integration and end-to-end tests.

> These are all testing mechanisms to ensure proper operation of software.
> A unit test is concerned with the proper operation of a single
> piece of functionality - for example, a function that squares an integer.
> An integration test would test the ability of a set of modules to properly 
> work together to perform some higher level function. For example, that
> a client could properly communicate over the Internet with a server.
> You're testing the client, server, and the Internet communication mechanism.
> An end-to-end test ensures proper input-output operation at a user level. For 
> example, that
> when a user pushes a button, a can of soda pops out.

- What is a mock? What are some things you would mock?

> A *mock* is a way to incorporate a functionality into a test without
> actually utilizing that functionality in the test, either because it
> will take too long, isn't available, or for whatever reason it's 
> undesirable to actually use that functionality. The mock emulates what
> should happen - at least to resemble a given output for a given input.
> The test is oblivious to the fact that a mock is being used.

- What is continuous integration?

> *Continuous integration* is a software development methodology where small, 
> incremental updates or improvements become part of the main build in relatively
> rapid fashion. Usually, automation is used to run tests and (if passed) update 
> the production system.

- What is an environment variable and what are they used for?

> An *environment variable* is a variable whose value depends on the setting in
> a system is to be run. For example, one might want to use a special database when
> testing, that contains different data from the production system database.
> An environment variable (e.g. 'databaseName') could store the name of the database
> to be used and would be set appropriately depending on if the system were to be 
> run in a testing or production mode.

- What is TDD? What are some benefits and drawbacks?

> *TDD* stands for Test-Driven Development. It is a development methodology where
> functionality is defined in terms of the tests that will ensure that it's 
> performing properly. Development then proceeds directed toward making sure 
> that the resulting software pass those test.  
> 
> Advantages:  
> &nbsp;&nbsp;&nbsp;&nbsp;- testing is built-in, not an afterthought  
> &nbsp;&nbsp;&nbsp;&nbsp;- forces developers to think in practical terms about functionality  
> &nbsp;&nbsp;&nbsp;&nbsp;- forces more discipline in development process

> Disadvatages:  
> &nbsp;&nbsp;&nbsp;&nbsp;- Some things are difficult to write tests for. (e.g. user-interface)  
> &nbsp;&nbsp;&nbsp;&nbsp;- It may be better to leave testing to test engineers, who have the training and experience on what and how to test properly.  
> &nbsp;&nbsp;&nbsp;&nbsp;- Testing mechanisms available in the development process may be limited.

- What is the value of using JSONSchema for validation?

> It can be daunting and boring to test in JS code whether a complex piece of JSON data is properly structured. It is much more efficient to test the data against a template. The template could even be generated from some JSON data that fits the template.

- What are some ways to decide which code to test?

> Test boundary cases. Test simple cases. Test complex cases.  Don't test every 
> possibility; but, test a representative sample of cases.
> Test cases where the proper result is easy to determine, even if the process is complex.  For example, to sort a list, test on a permutation of 1,2,3,..10.

- What does `RETURNING` do in SQL? When would you use it?

> `RETURNING` causes SQL to return some values after an operation is completed.  
> It's beneficial to use with calls like `INSERT` or `DELETE` that would normally only return the number of records inserted or deleted. A calling function might benefit from more information than that. For example - on returning details on a deleted object to show to a user or to enable an "undelete" operation.

- What are some differences between Web Sockets and HTTP?

> With `Web Sockets` either the client or the server can initiate information flow. 
> A web browser client could request web page details from the web server; but,
> the web server could also send information (such as updates) to the web 
> browser client. This can result in more dynamic web pages (e.g. without 
> requiring web browser to recache the page & redisplay the entire page again).
> HTTP, in its original design at least, was meant to simply allow web browsers
> to render pages given information returned after a page request from the 
> browser to the server.  

- Did you prefer using Flask over Express? Why or why not (there is no right
  answer here --- we want to see how you think about technology)?

> I like JavaScript over Python.  
> I liked the `package.json` and `npm` mechanism in Node better than the `venv` mechanisms used in Flask.  
> My impression is that Express ran faster.